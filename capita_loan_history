#! /usr/bin/perl

# capita_loan_history

use v5.14;
use warnings;

use Const::Fast qw<const>;

use Getopt::Long qw<GetOptions :config gnu_getopt>;
use Web::Scraper qw<scraper process>;
use URI;
use LWP::UserAgent;
use HTTP::CookieJar::LWP;
use String::Util qw<trim>;


const my $Usage           => "$0: [-l LOCATION] CARD-NUMBER PIN\n";
const my $URLPrefix       => 'https://capitadiscovery.co.uk/';
const my $URLSuffix       => '/account/history';
const my $DefaultLocation => 'bradford';


GetOptions 'location|l=s' => \(my $location = $DefaultLocation) or die $Usage;
my $loans_url = URI->new("$URLPrefix\L$location\E$URLSuffix");

die $Usage if @ARGV != 2;
my ($card_number, $pin) = @ARGV;

# To access the user's account, we need to log in. Attempt to view the loan
# history page and it will redirect to a log-in form (which, on success, will
# redirect back to the requested page).
my $login_form =
(
  scraper
  {
    # We want the <form> with this class:
    process '//form[contains(@class, "loginForm")]', form => scraper
    {
      # Grab the URL the <form> submits to, the HTTP method, and the names and
      # values of all the contained <input> elements:
      process '//.', url => '@action', method => '@method';
      process '//input', 'field[]' => scraper
      {
        process '//.', 'name' => '@name', 'value' => '@value';
      };
    };
    result 'form';
  }
)->scrape($loans_url);

# A logged-in user is tracked using cookies, so we need a user-agent with a
# cookie jar:
my $user_agent = LWP::UserAgent->new(cookie_jar => HTTP::CookieJar::LWP->new);

# Submit the log-in <form>, using the found <input> elements, adding in the
# user's library card number and pin into the relevant fields, and see where it
# redirects us to:
my %param = ((map { $_->{name}, $_->{value} } @{$login_form->{field}}),
    barcode => $card_number, pin => $pin);
my $method = $login_form->{method};
my $logged_in_url = $user_agent->$method($login_form->{url}, \%param)
    ->header('Location');

# If logging in succeeded, this will have redirected us back to the URL we
# requested in the first place (but now with suitable cookies set). If it
# hasn't, then something's gone wrong:
die "Logging in failed: redirect to: $logged_in_url\n"
    if $logged_in_url ne $loans_url;

# Grab content from that page:
my $url = $loans_url;
while ($url)
{
  my $result =
  (
    scraper
    {
      # Only 10 books are listed at a time; if there are more there'll be a
      # link with the title ‘next’; grab the URL it links to:
      process '//a[@title="next"]', next_page => '@href';

      # The loan history is in a <table>, with each <tr> containing details of
      # a book. Restrict to <tbody>, to avoid grabbing the headers:
      process '//table[@id="history"]/tbody', book => scraper
      {
        process '//tr', 'book[]' => scraper
        {
          # There's a <th> on each row with the title and author. The title
          # links to the book's page in the catalogue, so grab the <a>'s
          # contents, removing spaces:
          process '//th/a', title => ['TEXT', sub { trim $_ }];

          # The author is in the same <th> outside of the <a>, in a handy
          # <span> (and without any extraneous spaces):
          process '//th/span[@class="author"]', author => 'TEXT';

          # The borrowed and returned dates are in separate <td>-s. Each have
          # the same class, so grab them in order:
          process '//td[@class="accDue"][1]', borrowed => 'TEXT';
          process '//td[@class="accDue"][2]', returned => 'TEXT';
        };
        result 'book';
      };
    }
  )->scrape($user_agent->get($url));

  # Emit each book as a tab-separated line:
  foreach (@{$result->{book}})
  {
    # Ignore the dates which are attached to some author's names. Surname,
    # forename, and dates (if included) are comma-separated, so just grab the
    # first 2 of those:
    my ($surname, $forename) = split /, /, $_->{author};

    no warnings qw<uninitialized>; # Some authors don't have forenames
    say join "\t",
        $_->{borrowed}, $_->{returned}, $forename, $surname, $_->{title};
  }

  # If there was a next page link, go round again with its URL; the last page
  # won't have such a link, ending the loop:
  $url = $result->{next_page};
}
